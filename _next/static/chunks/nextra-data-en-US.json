{"/about":{"title":"About Us","data":{"about-us#About Us":""}},"/blog":{"title":"Blog","data":{"blog#Blog":""}},"/community":{"title":"Community","data":{"community#Community":"Cloudinator Community"}},"/contact":{"title":"Contact Us","data":{"-contact-us#ðŸ“Œ Contact Us":"We would love to hear from you! Please fill out the form below to get in touch with our team.\nSend Message","-other-ways-to-react-us#ðŸ“Œ Other Ways to React Us":"Email: cloudinator@email.com\nPhone: +885 127 856 148\nAddress: Toul Kork, Phnom Penh City\nOur support team is available 24/7"}},"/deployment/backend/nestjs":{"title":"Nest.js Deployment","data":{"nestjs-deployment#NestJS Deployment":"","video-guide#Video Guide":"Here is a quick introduction video about Nestjs deployment in cloudinator:","resource#Resource":"Here is overview of project structure:"}},"/deployment/backend/nodejs":{"title":"Nodejs","data":{"nodejs-deployment#Node.js Deployment":""}},"/deployment/backend/spring":{"title":"Spring","data":{"spring-deployment#Spring Deployment":""}},"/deployment/database/mongodb":{"title":"Mongodb","data":{"mongodb-deployment#MongoDB Deployment":""}},"/deployment/database/postgres":{"title":"Postgres","data":{"postgresql-deployment#PostgreSQL Deployment":""}},"/deployment/frontend/html":{"title":"HTML Deployment","data":{"html-deployment#HTML Deployment":"Here is a step-by-step guide on how to deploy your HTML static site on Cloudinator:","video-guide#Video Guide":"Here is a quick introduction video about HTML deployment in cloudinator:","resource#Resource":"Here is overview of project structure:"}},"/deployment/frontend/laravel":{"title":"Laravel","data":{"laravel-deployment#Laravel Deployment":""}},"/deployment/frontend/nextjs":{"title":"Next.js Deployment","data":{"nextjs-deployment#Next.js Deployment":"Here is a step-by-step guide on how to deploy your Nextjs site on Cloudinator:","video-guide#Video Guide":"Here is a quick introduction video about Nextjs deployment in cloudinator:","resource#Resource":"Here is overview of project structure:"}},"/deployment/frontend/nuxt":{"title":"Nuxt.js Deployment","data":{"nuxtjs-deployment#Nuxtâ€‹.js Deployment":"Here is a step-by-step guide on how to deploy your Nuxt.js Project on Cloudinator:","video-guide#Video Guide":"Here is a quick introduction video about Nuxt.js deployment in cloudinator:","resource#Resource":"Here is overview of project structure:"}},"/deployment/frontend/react":{"title":"React.js Deployment","data":{"reactjs-deployment#React.js Deployment":"Here is a step-by-step guide on how to deploy your React.js on Cloudinator:","video-guide#Video Guide":"Here is a quick introduction video about Nextjs deployment in cloudinator:","resource#Resource":"Here is overview of project structure:"}},"/deployment/frontend/vite":{"title":"Vite","data":{"vite-deployment#Vite Deployment":"Here is a step-by-step guide on how to deploy your Vite on Cloudinator:"}},"/deployment/frontend/vue":{"title":"Vue Deployment","data":{"vue-deployment#Vue Deployment":"Here is a step-by-step guide on how to deploy your Vue on Cloudinator:","video-guide#Video Guide":"Here is a quick introduction video about Vue deployment in cloudinator:","resource#Resource":"Here is overview of project structure:"}},"/getting-started":{"title":"Getting Started","data":{"":"Welcome to the Cloudinator getting started guide. This document will help you set up Cloudinator and guide you through basic usage.","-prerequisites#ðŸ“Œ Prerequisites":"Before you begin, ensure you have the following:\nOperating System (Windows, macOS, or Linux)\nConcept DevOps\nUnderstanding of Basic Programming"}},"/":{"title":"Introduction to Cloudinator","data":{"":"Say Goodbye to Manual, Say hello to Automation!","-overview#ðŸ“Œ Overview":"Cloudinator streamlines application deployment for monolithic and microservices architectures with customizable domain management.","-what-youll-learn#ðŸ“Œ What You'll Learn":"Platform fundamentals\nStep-by-step deployment tutorials\nCreating deployment services","-quick-start-video#ðŸ“Œ Quick Start Video":""}},"/installation":{"title":"Installation","data":{"":"Select service you want to deploy\nFrameworks"}},"/resource/nuxtjs/introduction":{"title":"Introduction","data":{"nuxtjs-for-beginner#Nuxt.js For Beginner":""}},"/resource/spring-microservice/core-concepts":{"title":"Core Concepts","data":{"core-concepts#Core Concepts":"Spring Microservices are built on key concepts:\nService Discovery: Services register themselves with a discovery server (like Eureka). Other services locate them dynamically rather than using hardcoded URLs.\nAPI Gateway: Single entry point that routes requests to appropriate microservices, handles authentication, and load balancing. Spring Cloud Gateway is commonly used.\nLoad Balancing: Distributes traffic across service instances using client-side (Ribbon) or server-side balancing.\nCircuit Breaker: Prevents cascade failures by monitoring service health and providing fallbacks (using Resilience4j or Hystrix).\nConfiguration Management: Externalized configuration using Spring Cloud Config Server for centralized management across services.\nService Communication:\nSynchronous: REST/HTTP using RestTemplate or WebClient\nAsynchronous: Message queues like RabbitMQ/Kafka\nDistributed Tracing: Tracks requests across services using tools like Spring Cloud Sleuth and Zipkin."}},"/resource/spring-microservice/getting-started":{"title":"Getting Started","data":{"getting-started#Getting Started":""}},"/resource/spring-microservice/introduction":{"title":"Introduction","data":{"introduction#Introduction":"","overview-of-spring-microservices#Overview of Spring Microservices":"Spring Microservices refer to the implementation of a microservice architecture using the Spring Framework, specifically the Spring Boot and Spring Cloud projects. A microservice architecture breaks down an application into smaller, independently deployable services that communicate with each other over a network.\nSpring Boot: Provides a way to quickly create stand-alone, production-ready Spring-based applications with minimal configuration. It includes embedded servers and simplifies the process of setting up, configuring, and running microservices.\nSpring Cloud: A set of tools designed to make it easier to build distributed systems, focusing on areas like configuration management, service discovery, and fault tolerance. Spring Cloud provides a rich set of services to integrate microservices, helping with:\nService Discovery (Eureka, Consul)\nAPI Gateway (Spring Cloud Gateway)\nDistributed Configuration Management (Spring Cloud Config)\nCircuit Breakers (Hystrix, Resilience4j)\nLoad Balancing (Ribbon)\nTogether, these two frameworks allow developers to build highly scalable and flexible microservices applications with minimal effort.","benefits-of-microservice-architecture#Benefits of Microservice Architecture":"Microservice architecture offers several advantages over traditional monolithic applications, especially when dealing with large-scale, distributed systems. Below are some key benefits:1. Scalability\nEach microservice can be scaled independently, meaning that only the services with higher demand need to be scaled, rather than scaling the entire application.\nThis enables horizontal scaling for specific services that experience high traffic, leading to more efficient resource utilization.\n2. Flexibility and Technology Agnostic\nMicroservices allow each service to be developed using different programming languages, frameworks, or data stores based on the specific requirements of that service. For instance, one service might be written in Java, while another could use Node.js, allowing for the selection of the most appropriate technology for each task.\n3. Improved Fault Isolation\nSince each service runs independently, if one microservice fails, it doesn't necessarily bring down the entire application. Fault isolation means that failures are contained within the service, making the system more resilient.\nThis improves the availability and reliability of the application as a whole.\n4. Faster Development and Deployment\nMicroservices can be developed and deployed independently, making it easier to update individual components without impacting the rest of the system.\nTeams can work on separate services concurrently, allowing for parallel development. This leads to faster release cycles and more frequent updates.\n5. Simplified Maintenance\nSince each microservice is smaller and focused on a specific business domain, the codebase is easier to understand, maintain, and modify.\nBug fixing and feature enhancements are more isolated, which reduces the complexity associated with managing large codebases.\n6. Better Resource Utilization\nMicroservices, being independently deployable and scalable, can be run on different machines, containers, or even cloud environments. This means the underlying infrastructure can be optimized and resources allocated as needed.\n7. Enhanced Securiy\nMicroservices can be secured individually, making it easier to enforce access control, authentication, and authorization at the service level.\nSecurity policies can be more granular and applied specifically to the service or API that requires it.\n8. Easier to Update and Deploy\nMicroservices allow continuous integration/continuous delivery (CI/CD) pipelines to be easily implemented. With microservices, changes to a single service can be tested, deployed, and rolled back independently of other services.\nThis makes updating and deploying faster and less risky, as services can be rolled out without needing to redeploy the entire application.\n9. Organizational Benefits\nMicroservices enable teams to focus on specific business functionalities, making development efforts more specialized.\nThey promote a DevOps culture by fostering collaboration between development and operations teams.\n10. Easier Integration with Third-Party Services\nMicroservices expose their functionalities as APIs, which makes it easier to integrate with third-party services or other microservices.\nThis allows businesses to leverage external services and build upon their own functionality without being overly dependent on any one service."}},"/resource/spring-microservice/spring-boot":{"title":"Spring Boot","data":{"spring-boot#Spring Boot":"","introduction-to-spring-boot#Introduction to Spring Boot":"Spring Boot is a framework that provides a streamlined and efficient way to create stand-alone, production-ready Spring-based applications with minimal configuration. It is built on top of the Spring Framework and aims to simplify the process of building and deploying microservices and other types of applications.","key-features-of-spring-boot#Key Features of Spring Boot":"","stand-alone-applications#Stand-Alone Applications":"Spring Boot revolutionizes Java application development by enabling the creation of self-contained, production-grade applications that can run independently. This document explores the key aspects of Spring Boot's stand-alone application capabilities and how to implement them effectively.a. Embedded Server SupportSpring Boot includes embedded server support out of the box, eliminating the need for external application server deployment. The most commonly used servers include:\nTomcat (default for web applications)\nJetty\nUndertow\nThese servers are automatically configured and started when the application launches.b. Self-Contained JAR FilesSpring Boot applications can be packaged as executable JAR files that include:\nApplication Code\nRequired dependencies\nEmbedded server\nApplication configuration\nStatic resources\nc. Configuration ManagementStand-alone applications benefit from Spring Boot's robust configuration capabilities:\nApplication properties can be externalized\nEnvironment-specific configurations\nEasy override mechanisms\nSupport for multiple configuration formats (properties, YAML)","embedded-servers#Embedded Servers":"Spring Boot includes embedded servers like Tomcat, Jetty, and Undertow, eliminating the need to set up and manage external servers. This feature is particularly useful for microservices, where each service can be packaged and run independently. An embedded server is a lightweight server that comes bundled within your application JAR/WAR file. When you run your Spring Boot application, the embedded server starts automatically as part of your application process, rather than running as a separate process like traditional application servers.Key Embedded Servers in Spring Boot:\nTomcat: The default embedded server for Spring Boot web applications. It is excellent for serving web applications and JSPs, lightweight, well-tested and has default port 8080\nJetty: Another popular embedded server that is known for its speed and scalability. It is great for handling WebSocket connections and popular in embedded and cloud environments.\nUndertow: A high-performance web server that is designed for modern applications. It is known for its asynchronous capabilities and is well-suited for microservices and reactive applications.","minimal-configuration#Minimal Configuration":"With Spring Boot's opinionated defaults, developers can focus on application logic rather than boilerplate configurations. It comes with sensible default settings and automatically configures essential components.\nAuto-Configuration: Spring Boot automatically configures beans based on the classpath and dependencies present in the project.\nStarter Dependencies: Spring Boot Starter dependencies simplify the inclusion of common libraries and frameworks by providing pre-configured dependencies.\nDefault Property Settings: Spring Boot provides sensible default settings for various properties, reducing the need for manual configuration.\nKey Areas of Auto-Configuration:\nDatabase Configuration\nSecurity Defaults\nWeb MVC Configuration","microservices-support#Microservices Support":"Spring Boot is designed with microservices architecture in mind. It integrates seamlessly with Spring Cloud to provide features like service discovery, configuration management, and distributed tracing. Spring Boot's microservices support revolves around these key capabilities:Service Discovery\nUses Netflix Eureka or Consul to automatically register and locate services\nServices can find and communicate with each other without hardcoded URLs\nEnables dynamic scaling and failover\nConfiguration Management\nSpring Cloud Config provides centralized configuration for all microservices\nConfigurations can be updated without redeploying services\nSupports version control and environment-specific configs\nDistributed Tracing\nTools like Sleuth and Zipkin track requests across multiple services\nHelps debug and monitor request flows through the system\nProvides timing and dependency information\nAdditional Features\nCircuit breakers (Hystrix) for fault tolerance\nClient-side load balancing (Ribbon)\nAPI gateway support (Spring Cloud Gateway)\nMessage brokers integration for async communication","production-ready#Production Ready":"Spring Boot offers a range of production-ready features, including monitoring, health checks, metrics, and logging, through the Spring Boot Actuator module.Health Checks\n/health endpoint shows application health status\nCustom health indications for databases, services and dependencies\nAggregates status of all system components\nMetrics\n/metrics endpoint exposes key performance data\nJVM stas, memory usage, thread configurations\nCustom metrics for business-specific monitoring\nIntegrates with monitoring systems like Prometheus\nLoggging\nConfigurable log levels via /loggers endpoint\nRuntime log adjustment without restart\nStructured logging support\nAdditional Features\n/info for application info and build details\nEnvironment configuration viewing\nThread dump analysis\nHTTP trace monitoring\nCustom endpoints for specific monitoring needs","dependency-management#Dependency Management":"Spring Boot's dependency management is a powerful feature that simplifies library configuration through Starter dependencies.Spring Boot Starters\nPre-configured dependencies for common libraries and frameworks\nAutomatically included when using specific Spring Boot features\nEliminate version conflicts and compatibility issues\nBenefits\nReduces boilerplate configuration\nEnsures tested and compatible dependency versions\nSimplifies build file Maintenance\nProvide consistent dependency management across projects","devtools-for-faster-development#DevTools for Faster Development":"Spring Boot's DevTools module enhances the developer experience by enabling features like automatic reloads, live reload, and caching optimizations during development.\nAutomatic restarts\nLive Reload\nProperty Defaults\nRemote Development Support\nDevelopment-specific Configuration\nGlobal Settings\nFile Watch Configuration\nperformance Considerations","integration-with-spring-ecosystem#Integration with Spring Ecosystem":"8. Integration with Spring EcosystemSpring Boot seamlessly integrates with other Spring projects, such as Spring Data, Spring Security, and Spring Batch, providing a cohesive development experience.\nSpring Data Integration\nSpring Security Integration\nSpring Cloud Integration\nSpring Batch Integration\nSpring WebFlux Integration\nSpring Cache Integration\nSpring Messaging Integration\nSpring Testing Integration","benefits-of-using-spring-boot#Benefits of Using Spring Boot":"1. Quick StartSpring Boot accelerates development by eliminating the need for extensive configuration and setup, enabling developers to start coding right away.2. Simplified DeploymentSince Spring Boot applications include an embedded server, they can be easily packaged as JAR or WAR files and deployed across various environments.3. Enhanced ScalabilitySpring Boot applications are inherently lightweight and modular, making them ideal for scaling in distributed environments like cloud platforms.4. Reduced Boilerplate CodeWith its convention-over-configuration approach, Spring Boot reduces the need for repetitive and verbose coding practices.5. Robust Community SupportSpring Boot is backed by a large and active community, ensuring regular updates, extensive documentation, and support.","user-cases-for-spring-boot#User Cases for Spring Boot":"1. Building MicroservicesSpring Boot is a preferred choice for creating microservices due to its embedded servers, simplified configuration, and seamless integration with cloud-native tools.2. RESTful APIsWith its robust web support, Spring Boot makes it easy to create REST APIs that can handle JSON, XML, and other data formats.3. Enterprise ApplicationsLarge-scale, enterprise-grade applications benefit from Spring Boot's integration with other Spring projects and its production-ready features.4. Batch ProcessingUsing Spring Boot in conjunction with Spring Batch enables efficient batch job execution with minimal setup."}},"/spring-microservice/create":{"title":"Create","data":{"create-spring-microservice#Create Spring Microservice":""}},"/spring-microservice/deployment":{"title":"Deployment","data":{"spring-microservice-deployment#Spring Microservice Deployment":"Here is a step-by-step guide on how to deploy your Spring Microservice on Cloudinator:"}},"/tutorial":{"title":"Tutorial","data":{"tutorial#Tutorial":""}},"/spring-microservice/workspace":{"title":"Workspace","data":{"workspace#Workspace":""}}}